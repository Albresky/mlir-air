diff --git a/mlir/include/air/Util/Dependency.h b/mlir/include/air/Util/Dependency.h
index d9d13d5c..e3706adc 100644
--- a/mlir/include/air/Util/Dependency.h
+++ b/mlir/include/air/Util/Dependency.h
@@ -12,7 +12,8 @@
 // primarily AIR dependency tracing passes.
 //===----------------------------------------------------------------------===//
 
-#pragma once
+#ifndef AIR_UTIL_DEPENDENCY_H
+#define AIR_UTIL_DEPENDENCY_H
 
 #include "air/Dialect/AIR/AIRDialect.h"
 #include "air/Util/Util.h"
@@ -148,7 +149,7 @@ typedef boost::graph_traits<Graph>::vertex_iterator vertex_iterator;
 struct dependencyGraph {
   Graph g;
   mlir::Operation *hierarchyOp;
-  std::deque<dependencyGraph> subgraphs;
+  std::deque<std::shared_ptr<dependencyGraph>> subgraphs;
   runnerNode *runner_node;
   Graph::vertex_descriptor start_vertex;
   Graph::vertex_descriptor terminator_vertex;
@@ -268,15 +269,15 @@ public:
   void redoDepTraceIfDepOnHier(func::FuncOp func);
 
 private:
-  void addVerticesInHerd(std::deque<dependencyGraph> &herd_subgraphs,
+  void addVerticesInHerd(std::deque<std::shared_ptr<dependencyGraph>> &herd_subgraphs,
                          air::HerdOp herd, dependencyContext &dep_ctx,
                          graphGranularityProperties expandHier = {true, true,
                                                                   true, false});
-  void addVerticesInSegment(std::deque<dependencyGraph> &part_subgraphs,
+  void addVerticesInSegment(std::deque<std::shared_ptr<dependencyGraph>> &part_subgraphs,
                             air::SegmentOp segment, dependencyContext &dep_ctx,
                             graphGranularityProperties expandHier = {
                                 true, true, true, false});
-  void addVerticesInLaunch(std::deque<dependencyGraph> &launch_subgraphs,
+  void addVerticesInLaunch(std::deque<std::shared_ptr<dependencyGraph>> &launch_subgraphs,
                            air::LaunchOp launch, dependencyContext &dep_ctx,
                            graphGranularityProperties expandHier = {
                                true, true, true, false});
@@ -442,3 +443,5 @@ private:
 
 } // namespace air
 } // namespace xilinx
+
+#endif
\ No newline at end of file
diff --git a/mlir/lib/Conversion/AIRToAIEPass.cpp b/mlir/lib/Conversion/AIRToAIEPass.cpp
index ce227c4e..0a008804 100644
--- a/mlir/lib/Conversion/AIRToAIEPass.cpp
+++ b/mlir/lib/Conversion/AIRToAIEPass.cpp
@@ -1274,7 +1274,7 @@ private:
     return true;
   }
 
-  std::vector<unsigned> convertToStdVec(SmallVector<int64_t, 4> vec) const {
+  std::vector<unsigned> convertToStdVec(SmallVector<int64_t, 4> vec) const {
     std::vector<unsigned> output;
     for (auto v : vec) {
       output.push_back((unsigned)v);
diff --git a/mlir/lib/Transform/AIRLinalgCodegen.cpp b/mlir/lib/Transform/AIRLinalgCodegen.cpp
index 88041359..7f5bd951 100644
--- a/mlir/lib/Transform/AIRLinalgCodegen.cpp
+++ b/mlir/lib/Transform/AIRLinalgCodegen.cpp
@@ -1394,7 +1394,7 @@ public:
     assert(op.getNumLoops() == tileSizes->size() && "invalid tile size count");
     for (unsigned i = 0, e = op.getNumLoops(); i < e; i++) {
       auto &tFactorAdjusted = (*tileSizes)[i];
-      tFactorAdjusted = std::max(1L, tripCounts[i] / tFactorAdjusted);
+      tFactorAdjusted = std::max((int64_t)1, tripCounts[i] / tFactorAdjusted);
       // Adjust the tile size to largest factor of the trip count less than
       // tSize.
       auto constTripCount = tripCounts[i];
diff --git a/mlir/lib/Util/Dependency.cpp b/mlir/lib/Util/Dependency.cpp
index 24dd03fd..957a5d78 100644
--- a/mlir/lib/Util/Dependency.cpp
+++ b/mlir/lib/Util/Dependency.cpp
@@ -11,7 +11,11 @@
 
 #include "mlir/Transforms/GreedyPatternRewriteDriver.h"
 
+#ifdef _WIN32
+#include <direct.h>
+#else
 #include <sys/stat.h>
+#endif
 
 #define DEBUG_TYPE "air-dependency-util"
 
@@ -526,22 +530,22 @@ void dependencyCanonicalizer::parseCommandGraphs(func::FuncOp &toplevel,
   // Adds edges between async ops
   parseDependencyEdgesInGraph(global_graph.g, dep_ctx);
   for (auto &G_l : global_graph.subgraphs) {
-    parseDependencyEdgesInGraph(G_l.g, dep_ctx);
-    for (auto &G_p : G_l.subgraphs) {
-      parseDependencyEdgesInGraph(G_p.g, dep_ctx);
-      for (auto &G_h : G_p.subgraphs) {
-        parseDependencyEdgesInGraph(G_h.g, dep_ctx);
+    parseDependencyEdgesInGraph(G_l->g, dep_ctx);
+    for (auto &G_p : G_l->subgraphs) {
+      parseDependencyEdgesInGraph(G_p->g, dep_ctx);
+      for (auto &G_h : G_p->subgraphs) {
+        parseDependencyEdgesInGraph(G_h->g, dep_ctx);
       }
     }
   }
 
   // Connect leaf vertices to launch, segment and herd terminators
   for (auto &G_l : global_graph.subgraphs) {
-    connectTerminatorInGraph(G_l.g);
-    for (auto &G_p : G_l.subgraphs) {
-      connectTerminatorInGraph(G_p.g);
-      for (auto &G_h : G_p.subgraphs) {
-        connectTerminatorInGraph(G_h.g);
+    connectTerminatorInGraph(G_l->g);
+    for (auto &G_p : G_l->subgraphs) {
+      connectTerminatorInGraph(G_p->g);
+      for (auto &G_h : G_p->subgraphs) {
+        connectTerminatorInGraph(G_h->g);
       }
     }
   }
@@ -552,18 +556,18 @@ void dependencyCanonicalizer::parseCommandGraphs(func::FuncOp &toplevel,
   updatePointerFromGraphToHierarchyTerminator(global_graph);
   updatePointerFromHierarchyOpToGraph(global_graph);
   for (auto &launchGraph : global_graph.subgraphs) {
-    connectStartNodeInCommandGraph(launchGraph);
-    updatePointerFromGraphToHierarchyTerminator(launchGraph);
-    updatePointerFromHierarchyTerminatorToGraph(global_graph, launchGraph);
-    updatePointerFromHierarchyOpToGraph(launchGraph);
-    for (auto &segmentGraph : launchGraph.subgraphs) {
-      connectStartNodeInCommandGraph(segmentGraph);
-      updatePointerFromGraphToHierarchyTerminator(segmentGraph);
-      updatePointerFromHierarchyTerminatorToGraph(launchGraph, segmentGraph);
-      updatePointerFromHierarchyOpToGraph(segmentGraph);
-      for (auto &herdGraph : segmentGraph.subgraphs) {
-        connectStartNodeInCommandGraph(herdGraph);
-        updatePointerFromGraphToHierarchyTerminator(herdGraph);
+    connectStartNodeInCommandGraph(*launchGraph);
+    updatePointerFromGraphToHierarchyTerminator(*launchGraph);
+    updatePointerFromHierarchyTerminatorToGraph(global_graph, *launchGraph);
+    updatePointerFromHierarchyOpToGraph(*launchGraph);
+    for (auto &segmentGraph : launchGraph->subgraphs) {
+      connectStartNodeInCommandGraph(*segmentGraph);
+      updatePointerFromGraphToHierarchyTerminator(*segmentGraph);
+      updatePointerFromHierarchyTerminatorToGraph(*launchGraph, *segmentGraph);
+      updatePointerFromHierarchyOpToGraph(*segmentGraph);
+      for (auto &herdGraph : segmentGraph->subgraphs) {
+        connectStartNodeInCommandGraph(*herdGraph);
+        updatePointerFromGraphToHierarchyTerminator(*herdGraph);
       }
     }
   }
@@ -589,15 +593,15 @@ void dependencyCanonicalizer::copyDependencyGraphToFlatGraphAndVisualize(
   maps.push_back(map);
   for (auto &G_l : global_graph.subgraphs) {
     vertex_to_flat_vertex_map map_l;
-    copyFromDependencyGraphToFlatGraph(G_l.g, G_l.position, flat_g, map_l);
+    copyFromDependencyGraphToFlatGraph(G_l->g, G_l->position, flat_g, map_l);
     maps.push_back(map_l);
-    for (auto &G_p : G_l.subgraphs) {
+    for (auto &G_p : G_l->subgraphs) {
       vertex_to_flat_vertex_map map_p;
-      copyFromDependencyGraphToFlatGraph(G_p.g, G_p.position, flat_g, map_p);
+      copyFromDependencyGraphToFlatGraph(G_p->g, G_l->position, flat_g, map_p);
       maps.push_back(map_p);
-      for (auto &G_h : G_p.subgraphs) {
+      for (auto &G_h : G_p->subgraphs) {
         vertex_to_flat_vertex_map map_h;
-        copyFromDependencyGraphToFlatGraph(G_h.g, G_h.position, flat_g, map_h);
+        copyFromDependencyGraphToFlatGraph(G_h->g, G_l->position, flat_g, map_h);
         maps.push_back(map_h);
       }
     }
@@ -609,13 +613,13 @@ void dependencyCanonicalizer::copyDependencyGraphToFlatGraphAndVisualize(
   collectAIRChannelPutAndGetInGraph(global_graph.g, global_graph.position,
                                     maps[index++], channel_map);
   for (auto &G_l : global_graph.subgraphs) {
-    collectAIRChannelPutAndGetInGraph(G_l.g, G_l.position, maps[index++],
+    collectAIRChannelPutAndGetInGraph(G_l->g, G_l->position, maps[index++],
                                       channel_map);
-    for (auto &G_p : G_l.subgraphs) {
-      collectAIRChannelPutAndGetInGraph(G_p.g, G_p.position, maps[index++],
+    for (auto &G_p : G_l->subgraphs) {
+      collectAIRChannelPutAndGetInGraph(G_p->g, G_p->position, maps[index++],
                                         channel_map);
-      for (auto &G_h : G_p.subgraphs) {
-        collectAIRChannelPutAndGetInGraph(G_h.g, G_h.position, maps[index++],
+      for (auto &G_h : G_p->subgraphs) {
+        collectAIRChannelPutAndGetInGraph(G_h->g, G_h->position, maps[index++],
                                           channel_map);
       }
     }
@@ -731,7 +735,11 @@ void dependencyCanonicalizer::copyDependencyGraphToFlatGraphAndVisualize(
   if (dump_dot) {
     // Dump dot graphs
     if (dump_dir != "") {
+#ifdef _WIN32
+      int status = mkdir(dump_dir.c_str());
+#else
       int status = mkdir(dump_dir.c_str(), 0777);
+#endif
       if ((status < 0) && (errno != EEXIST))
         dump_dir = ""; // Failed to create dir
     }
@@ -752,15 +760,15 @@ void dependencyCanonicalizer::
 }
 
 void dependencyCanonicalizer::addVerticesInHerd(
-    std::deque<dependencyGraph> &herd_subgraphs, air::HerdOp herd,
+    std::deque<std::shared_ptr<dependencyGraph>> &herd_subgraphs, air::HerdOp herd,
     dependencyContext &dep_ctx, graphGranularityProperties expandHier) {
   // Build up herd graph
   bool showCores = std::get<3>(expandHier);
   if (showCores) {
     auto hier = dyn_cast<air::HierarchyInterface>(herd.getOperation());
     for (unsigned i = 0; i < getTripCountInHierarchyOp(hier); i++) {
-      herd_subgraphs.push_back(dependencyGraph(herd.getOperation(), true));
-      dependencyGraph *current_herd_graph = &(herd_subgraphs.back());
+      herd_subgraphs.push_back(std::make_shared<dependencyGraph>(herd.getOperation(), true));
+      dependencyGraph *current_herd_graph = herd_subgraphs.back().get();
 
       // Core id
       auto current_position = getPositionFromIterator(i, herd);
@@ -782,8 +790,8 @@ void dependencyCanonicalizer::addVerticesInHerd(
       });
     }
   } else {
-    herd_subgraphs.push_back(dependencyGraph(herd.getOperation(), true));
-    dependencyGraph *current_herd_graph = &(herd_subgraphs.back());
+    herd_subgraphs.push_back(std::make_shared<dependencyGraph>(herd.getOperation(), true));
+    dependencyGraph *current_herd_graph = herd_subgraphs.back().get();
 
     herd.walk([&](Operation *herd_childop) {
       if (!dyn_cast<air::HerdOp>(herd_childop)) {
@@ -794,11 +802,11 @@ void dependencyCanonicalizer::addVerticesInHerd(
 }
 
 void dependencyCanonicalizer::addVerticesInSegment(
-    std::deque<dependencyGraph> &part_subgraphs, air::SegmentOp segment,
+    std::deque<std::shared_ptr<dependencyGraph>> &part_subgraphs, air::SegmentOp segment,
     dependencyContext &dep_ctx, graphGranularityProperties expandHier) {
   // Build up segment graph
-  part_subgraphs.push_back(dependencyGraph(segment.getOperation(), true));
-  dependencyGraph *current_part_graph = &(part_subgraphs.back());
+  part_subgraphs.push_back(std::make_shared<dependencyGraph>(segment.getOperation(), true));
+  dependencyGraph *current_part_graph = part_subgraphs.back().get();
 
   segment.walk([&](Operation *part_childop) {
     if (!part_childop->getParentOfType<air::HerdOp>() &&
@@ -813,11 +821,11 @@ void dependencyCanonicalizer::addVerticesInSegment(
 }
 
 void dependencyCanonicalizer::addVerticesInLaunch(
-    std::deque<dependencyGraph> &launch_subgraphs, air::LaunchOp launch,
+    std::deque<std::shared_ptr<dependencyGraph>> &launch_subgraphs, air::LaunchOp launch,
     dependencyContext &dep_ctx, graphGranularityProperties expandHier) {
   // Build up launch graph
-  launch_subgraphs.push_back(dependencyGraph(launch.getOperation(), true));
-  dependencyGraph *current_launch_graph = &(launch_subgraphs.back());
+  launch_subgraphs.push_back(std::make_shared<dependencyGraph>(launch.getOperation(), true));
+  dependencyGraph *current_launch_graph = launch_subgraphs.back().get();
 
   launch.walk([&](Operation *launch_childop) {
     if (!launch_childop->getParentOfType<air::SegmentOp>() &&
@@ -1543,19 +1551,19 @@ void dependencyCanonicalizer::updatePointerFromHierarchyOpToGraph(
   }
   for (auto v : hier_vs) {
     // If expand cores in herd
-    if (G.subgraphs[idx].position.size()) {
+    if (G.subgraphs[idx]->position.size()) {
       if (!isa<air::HerdOp>(G.g[*v].op))
         G.g[*v].op->emitOpError("found non-herd op with core id");
       auto hier = dyn_cast<air::HierarchyInterface>(G.g[*v].op);
       for (unsigned i = 0; i < getTripCountInHierarchyOp(hier); i++) {
-        G.g[*v].nextDependencyGraphs.push_back(&(G.subgraphs[idx]));
-        if (G.g[*v].op != G.subgraphs[idx].hierarchyOp)
+        G.g[*v].nextDependencyGraphs.push_back(G.subgraphs[idx].get());
+        if (G.g[*v].op != G.subgraphs[idx]->hierarchyOp)
           G.g[*v].op->emitOpError("mismatch between graph and hierarchy op");
         idx++;
       }
     } else {
-      G.g[*v].nextDependencyGraphs.push_back(&(G.subgraphs[idx]));
-      if (G.g[*v].op != G.subgraphs[idx].hierarchyOp)
+      G.g[*v].nextDependencyGraphs.push_back(G.subgraphs[idx].get());
+      if (G.g[*v].op != G.subgraphs[idx]->hierarchyOp)
         G.g[*v].op->emitOpError("mismatch between graph and hierarchy op");
       idx++;
     }
@@ -1582,22 +1590,22 @@ void dependencyCanonicalizer::canonicalizeGraphs(
 
   // Construct empty post-canonicalization dependency graph, tr_graph
   for (auto &launchGraph : global_graph.subgraphs) {
-    tr_graph.subgraphs.push_back(dependencyGraph(launchGraph.hierarchyOp));
-    dependencyGraph *current_launch_graph = &(tr_graph.subgraphs.back());
+    tr_graph.subgraphs.push_back(std::make_shared<dependencyGraph>(launchGraph->hierarchyOp));
+    dependencyGraph *current_launch_graph = tr_graph.subgraphs.back().get();
     g_to_tr.submaps.push_back(vertex_to_vertex_map_tree());
     vertex_to_vertex_map_tree *current_launch_g_to_tr =
         &(g_to_tr.submaps.back());
-    for (auto &segmentGraph : launchGraph.subgraphs) {
+    for (auto &segmentGraph : launchGraph->subgraphs) {
       current_launch_graph->subgraphs.push_back(
-          dependencyGraph(segmentGraph.hierarchyOp));
+          std::make_shared<dependencyGraph>(segmentGraph->hierarchyOp));
       dependencyGraph *current_segment_graph =
-          &(current_launch_graph->subgraphs.back());
+          current_launch_graph->subgraphs.back().get();
       current_launch_g_to_tr->submaps.push_back(vertex_to_vertex_map_tree());
       vertex_to_vertex_map_tree *current_segment_g_to_tr =
           &(current_launch_g_to_tr->submaps.back());
-      for (auto &herdGraph : segmentGraph.subgraphs) {
+      for (auto &herdGraph : segmentGraph->subgraphs) {
         current_segment_graph->subgraphs.push_back(
-            dependencyGraph(herdGraph.hierarchyOp));
+            std::make_shared<dependencyGraph>(herdGraph->hierarchyOp));
         current_segment_g_to_tr->submaps.push_back(vertex_to_vertex_map_tree());
       }
     }
@@ -1615,32 +1623,32 @@ void dependencyCanonicalizer::canonicalizeGraphs(
   for (unsigned i = 0; i < global_size; i++) {
     auto &launchGraph = global_graph.subgraphs[i];
     auto &trLaunchGraph = tr_graph.subgraphs[i];
-    auto launch_size = launchGraph.subgraphs.size();
+    auto launch_size = launchGraph->subgraphs.size();
     auto launchMap = g_to_tr.submaps[i];
-    if (launch_size != trLaunchGraph.subgraphs.size())
-      launchGraph.hierarchyOp->emitOpError("graph tree size mismatch");
+    if (launch_size != trLaunchGraph->subgraphs.size())
+      launchGraph->hierarchyOp->emitOpError("graph tree size mismatch");
     if (launch_size != launchMap.submaps.size())
-      launchGraph.hierarchyOp->emitOpError(
+      launchGraph->hierarchyOp->emitOpError(
           "graph tree size and map size mismatch");
-    boostTransitiveReductionImpl(launchGraph.g, trLaunchGraph.g,
+    boostTransitiveReductionImpl(launchGraph->g, trLaunchGraph->g,
                                  launchMap.a_to_b, launchMap.b_to_a);
     for (unsigned j = 0; j < launch_size; j++) {
-      auto &segmentGraph = launchGraph.subgraphs[j];
-      auto &trSegmentGraph = trLaunchGraph.subgraphs[j];
-      auto segment_size = segmentGraph.subgraphs.size();
+      auto &segmentGraph = launchGraph->subgraphs[j];
+      auto &trSegmentGraph = trLaunchGraph->subgraphs[j];
+      auto segment_size = segmentGraph->subgraphs.size();
       auto segmentMap = launchMap.submaps[j];
-      if (segment_size != trSegmentGraph.subgraphs.size())
-        segmentGraph.hierarchyOp->emitOpError("graph tree size mismatch");
+      if (segment_size != trSegmentGraph->subgraphs.size())
+        segmentGraph->hierarchyOp->emitOpError("graph tree size mismatch");
       if (segment_size != segmentMap.submaps.size())
-        segmentGraph.hierarchyOp->emitOpError(
+        segmentGraph->hierarchyOp->emitOpError(
             "graph tree size and map size mismatch");
-      boostTransitiveReductionImpl(segmentGraph.g, trSegmentGraph.g,
+      boostTransitiveReductionImpl(segmentGraph->g, trSegmentGraph->g,
                                    segmentMap.a_to_b, segmentMap.b_to_a);
       for (unsigned k = 0; k < segment_size; k++) {
-        auto &herdGraph = segmentGraph.subgraphs[k];
-        auto &trHerdGraph = trSegmentGraph.subgraphs[k];
+        auto &herdGraph = segmentGraph->subgraphs[k];
+        auto &trHerdGraph = trSegmentGraph->subgraphs[k];
         auto herdMap = segmentMap.submaps[k];
-        boostTransitiveReductionImpl(herdGraph.g, trHerdGraph.g, herdMap.a_to_b,
+        boostTransitiveReductionImpl(herdGraph->g, trHerdGraph->g, herdMap.a_to_b,
                                      herdMap.b_to_a);
       }
     }
@@ -1656,27 +1664,31 @@ void dependencyCanonicalizer::dumpDotGraphFiles(dependencyGraph global_graph,
                                                 std::string dump_dir) {
   // Dump dot graphs
   if (dump_dir != "") {
+#ifdef _WIN32
+    int status = mkdir(dump_dir.c_str());
+#else
     int status = mkdir(dump_dir.c_str(), 0777);
+#endif
     if ((status < 0) && (errno != EEXIST))
       dump_dir = ""; // Failed to create dir
   }
   dump_graph(dump_dir + "host.dot", global_graph.g);
   int i = 0;
-  for (auto G_l : global_graph.subgraphs) {
-    std::string name = xilinx::air::to_string(G_l.hierarchyOp) + "_" +
+  for (auto &G_l : global_graph.subgraphs) {
+    std::string name = xilinx::air::to_string(G_l->hierarchyOp) + "_" +
                        std::to_string(++i) + ".dot";
-    dump_graph(dump_dir + name, G_l.g);
+    dump_graph(dump_dir + name, G_l->g);
     int j = 0;
-    for (auto G_p : G_l.subgraphs) {
-      std::string name = xilinx::air::to_string(G_p.hierarchyOp) + "_" +
+    for (auto &G_p : G_l->subgraphs) {
+      std::string name = xilinx::air::to_string(G_p->hierarchyOp) + "_" +
                          std::to_string(i) + "_" + std::to_string(++j) + ".dot";
-      dump_graph(dump_dir + name, G_p.g);
+      dump_graph(dump_dir + name, G_p->g);
       int k = 0;
-      for (auto G_h : G_p.subgraphs) {
-        std::string name = xilinx::air::to_string(G_h.hierarchyOp) + "_" +
+      for (auto &G_h : G_p->subgraphs) {
+        std::string name = xilinx::air::to_string(G_h->hierarchyOp) + "_" +
                            std::to_string(i) + "_" + std::to_string(j) + "_" +
                            std::to_string(++k) + ".dot";
-        dump_graph(dump_dir + name, G_h.g);
+        dump_graph(dump_dir + name, G_h->g);
       }
     }
   }
@@ -1717,11 +1729,11 @@ void dependencyCanonicalizer::updateDepList(func::FuncOp func,
   // Purge dependency list
   purgeAIRDepList(global_graph);
   for (auto &launchGraph : global_graph.subgraphs) {
-    purgeAIRDepList(launchGraph);
-    for (auto &segmentGraph : launchGraph.subgraphs) {
-      purgeAIRDepList(segmentGraph);
-      for (auto &herdGraph : segmentGraph.subgraphs) {
-        purgeAIRDepList(herdGraph);
+    purgeAIRDepList(*launchGraph);
+    for (auto &segmentGraph : launchGraph->subgraphs) {
+      purgeAIRDepList(*segmentGraph);
+      for (auto &herdGraph : segmentGraph->subgraphs) {
+        purgeAIRDepList(*herdGraph);
       }
     }
   }
@@ -1729,11 +1741,11 @@ void dependencyCanonicalizer::updateDepList(func::FuncOp func,
   // Rewrite dependency list
   fillAIRDepListUsingGraphTR(global_graph);
   for (auto &launchGraph : global_graph.subgraphs) {
-    fillAIRDepListUsingGraphTR(launchGraph);
-    for (auto &segmentGraph : launchGraph.subgraphs) {
-      fillAIRDepListUsingGraphTR(segmentGraph);
-      for (auto &herdGraph : segmentGraph.subgraphs) {
-        fillAIRDepListUsingGraphTR(herdGraph);
+    fillAIRDepListUsingGraphTR(*launchGraph);
+    for (auto &segmentGraph : launchGraph->subgraphs) {
+      fillAIRDepListUsingGraphTR(*segmentGraph);
+      for (auto &herdGraph : segmentGraph->subgraphs) {
+        fillAIRDepListUsingGraphTR(*herdGraph);
       }
     }
   }
diff --git a/mlir/lib/Util/Runner.cpp b/mlir/lib/Util/Runner.cpp
index cbe81b84..cdb6611e 100644
--- a/mlir/lib/Util/Runner.cpp
+++ b/mlir/lib/Util/Runner.cpp
@@ -391,7 +391,7 @@ public:
 
       // air launch iteration space
       int64_t iter_count = 1;
-      auto launch_op = dyn_cast<air::LaunchOp>(launchGraph.hierarchyOp);
+      auto launch_op = dyn_cast<air::LaunchOp>(launchGraph->hierarchyOp);
       for (auto s_op : launch_op.getSizeOperands()) {
         int64_t s = cast<arith::ConstantIndexOp>(s_op.getDefiningOp()).value();
         iter_count *= s;
@@ -400,13 +400,13 @@ public:
       for (unsigned i = 0; i < iter_count; i++) {
 
         // Reset controllers
-        launch_runner_node = runnerNode(nullptr, &launchGraph, "launch",
+        launch_runner_node = runnerNode(nullptr, launchGraph.get(), "launch",
                                         &dep_ctx, sim_granularity);
         // Update pointer to launch runner node in launch graph
-        launchGraph.runner_node = &launch_runner_node;
+        launchGraph->runner_node = &launch_runner_node;
 
         // Walk the launch graph and infer herd/segment runner nodes
-        launch_runner_node.initRunnerNodesFromLaunchGraph(launchGraph);
+        launch_runner_node.initRunnerNodesFromLaunchGraph(*launchGraph);
 
         // Schedule launch runner node and its sub-runner nodes
         scheduleLaunch(launch_runner_node, device_resource_node, time);
@@ -445,9 +445,9 @@ public:
 
       for (auto &segment_runner_node : launch.sub_runner_nodes) {
         running |=
-            processGraph(segment_runner_node, device_resource_node, time);
-        for (auto &herd_runner_node : segment_runner_node.sub_runner_nodes) {
-          running |= processGraph(herd_runner_node, device_resource_node, time);
+            processGraph(*segment_runner_node, device_resource_node, time);
+        for (auto &herd_runner_node : segment_runner_node->sub_runner_nodes) {
+          running |= processGraph(*herd_runner_node, device_resource_node, time);
         }
       }
 
@@ -457,19 +457,19 @@ public:
 
       for (auto &segment_runner_node : launch.sub_runner_nodes) {
         running |= pushOpsToWavefrontAndAllocateResource(
-            segment_runner_node, device_resource_node, time);
-        for (auto &herd_runner_node : segment_runner_node.sub_runner_nodes) {
+            *segment_runner_node, device_resource_node, time);
+        for (auto &herd_runner_node : segment_runner_node->sub_runner_nodes) {
           running |= pushOpsToWavefrontAndAllocateResource(
-              herd_runner_node, device_resource_node, time);
+              *herd_runner_node, device_resource_node, time);
         }
       }
 
       if (running) {
         launch.getTimeStampsFromWavefront(next_times);
         for (auto &segment_runner_node : launch.sub_runner_nodes) {
-          segment_runner_node.getTimeStampsFromWavefront(next_times);
-          for (auto &herd_runner_node : segment_runner_node.sub_runner_nodes) {
-            herd_runner_node.getTimeStampsFromWavefront(next_times);
+          segment_runner_node->getTimeStampsFromWavefront(next_times);
+          for (auto &herd_runner_node : segment_runner_node->sub_runner_nodes) {
+            herd_runner_node->getTimeStampsFromWavefront(next_times);
           }
         }
       }
@@ -511,15 +511,15 @@ private:
     for (auto &launchGraph : hostGraph.subgraphs) {
       // Write launch process name to trace metadata
       emitTraceMetadataEvent(traceStream, "process_name", "name",
-                             air::to_string(launchGraph.hierarchyOp), "M",
-                             getIdAttr(launchGraph.hierarchyOp));
+                             air::to_string(launchGraph->hierarchyOp), "M",
+                             getIdAttr(launchGraph->hierarchyOp));
       emitTraceMetadataEvent(traceStream, "process_sort_index", "sort_index",
-                             std::to_string(getIdAttr(launchGraph.hierarchyOp)),
-                             "M", getIdAttr(launchGraph.hierarchyOp));
-      for (auto &segmentGraph : launchGraph.subgraphs) {
+                             std::to_string(getIdAttr(launchGraph->hierarchyOp)),
+                             "M", getIdAttr(launchGraph->hierarchyOp));
+      for (auto &segmentGraph : launchGraph->subgraphs) {
         // Write segment process name to trace metadata
         std::string seg_process_info = "";
-        auto seg = dyn_cast<air::SegmentOp>(segmentGraph.hierarchyOp);
+        auto seg = dyn_cast<air::SegmentOp>(segmentGraph->hierarchyOp);
         seg_process_info += air::to_string(seg);
         seg_process_info += "[" + std::to_string(*seg.getNumCols()) + ", " +
                             std::to_string(*seg.getNumRows()) + "]";
@@ -528,14 +528,14 @@ private:
         emitTraceMetadataEvent(traceStream, "process_sort_index", "sort_index",
                                std::to_string(getIdAttr(seg)), "M",
                                getIdAttr(seg));
-        for (auto &herdGraph : segmentGraph.subgraphs) {
+        for (auto &herdGraph : segmentGraph->subgraphs) {
           // Only write herd process name metadata once per herd
           bool print_pid_metadata_for_herd = true;
           // Write core thread name metadata if showing cores
           bool print_tid_metadata_for_core = false;
-          if (herdGraph.position.size()) {
+          if (herdGraph->position.size()) {
             print_tid_metadata_for_core = true;
-            for (auto id : herdGraph.position) {
+            for (auto id : herdGraph->position) {
               if (id != 0) {
                 print_pid_metadata_for_herd = false;
               }
@@ -544,7 +544,7 @@ private:
           if (print_pid_metadata_for_herd) {
             // Write herd process name to trace metadata
             std::string herd_process_info = "";
-            auto herd = dyn_cast<air::HerdOp>(herdGraph.hierarchyOp);
+            auto herd = dyn_cast<air::HerdOp>(herdGraph->hierarchyOp);
             herd_process_info += air::to_string(herd);
             herd_process_info += "[" + std::to_string(herd.getNumCols()) +
                                  ", " + std::to_string(herd.getNumRows()) + "]";
@@ -557,22 +557,22 @@ private:
           if (print_tid_metadata_for_core) {
             // Write herd process name to trace metadata
             std::string thread_name =
-                "core [" + to_string(herdGraph.position) + "]";
+                "core [" + to_string(herdGraph->position) + "]";
             // Hardcoded maximum number of threads per core
             unsigned max_num_threads_per_core = 10;
             unsigned core_id = canonicalizer.getIteratorFromPosition(
-                                   herdGraph.position, herdGraph.hierarchyOp) *
+                                   herdGraph->position, herdGraph->hierarchyOp) *
                                    max_num_threads_per_core +
                                1;
             emitTraceMetadataEvent(traceStream, "thread_name", "name",
                                    thread_name, "M",
-                                   getIdAttr(herdGraph.hierarchyOp), core_id);
+                                   getIdAttr(herdGraph->hierarchyOp), core_id);
             // Iteratively write thread sort index for every possible thread in
             // a core
             for (unsigned i = 0; i < max_num_threads_per_core; i++) {
               emitTraceMetadataEvent(traceStream, "thread_sort_index",
                                      "sort_index", std::to_string(core_id + i),
-                                     "M", getIdAttr(herdGraph.hierarchyOp),
+                                     "M", getIdAttr(herdGraph->hierarchyOp),
                                      core_id + i);
             }
           }
diff --git a/mlir/lib/Util/Runner/RunnerNode.cpp b/mlir/lib/Util/Runner/RunnerNode.cpp
index 862807d8..1fd3743e 100644
--- a/mlir/lib/Util/Runner/RunnerNode.cpp
+++ b/mlir/lib/Util/Runner/RunnerNode.cpp
@@ -31,7 +31,7 @@ public:
   // An incomplete vector of vertices as candidates to wavefront
   std::vector<Graph::vertex_descriptor> latent_wavefront_candidates;
   // Sub runner nodes to the current runner node
-  std::deque<runnerNode> sub_runner_nodes;
+  std::deque<std::shared_ptr<runnerNode>> sub_runner_nodes;
   // Resource hierarchies which are allocated to this runner node
   std::vector<resourceHierarchy *> resource_hiers;
 
@@ -106,21 +106,23 @@ public:
         &(launchGraph.runner_node->channel_token_counts);
     for (auto &segmentGraph : launchGraph.subgraphs) {
       // Create segment runner node
-      this->sub_runner_nodes.push_back(runnerNode(
-          this, &segmentGraph, "segment", this->dep_ctx, this->sim_granularity,
+      this->sub_runner_nodes.push_back(std::make_shared<runnerNode>(
+          this, segmentGraph.get(), "segment", this->dep_ctx,
+          this->sim_granularity,
           &(launchGraph.runner_node->channel_token_counts)));
-      auto current_segment_node = &(this->sub_runner_nodes.back());
-      for (auto &herdGraph : segmentGraph.subgraphs) {
+      runnerNode current_segment_node = *this->sub_runner_nodes.back();
+      for (auto &herdGraph : segmentGraph->subgraphs) {
         // Create herd runner node
-        current_segment_node->sub_runner_nodes.push_back(
-            runnerNode(current_segment_node, &herdGraph, "herd", this->dep_ctx,
-                       this->sim_granularity,
-                       &(launchGraph.runner_node->channel_token_counts)));
+        current_segment_node.sub_runner_nodes.push_back(
+            std::make_shared<runnerNode>(
+                &current_segment_node, herdGraph.get(), "herd", this->dep_ctx,
+                this->sim_granularity,
+                &(launchGraph.runner_node->channel_token_counts)));
       }
     }
     this->addPointerBetweenSubRunnerNodeAndSubCommandGraph();
     for (auto &segment_runner_node : this->sub_runner_nodes) {
-      segment_runner_node.addPointerBetweenSubRunnerNodeAndSubCommandGraph();
+      segment_runner_node->addPointerBetweenSubRunnerNodeAndSubCommandGraph();
     }
   }
 
@@ -1261,8 +1263,7 @@ private:
 
   // Adds pointer between runner node and command graph
   void addPointerBetweenSubRunnerNodeAndSubCommandGraph() {
-    for (auto r_it = std::begin(this->sub_runner_nodes);
-         r_it != std::end(this->sub_runner_nodes); ++r_it) {
+    for (const auto &r_it : this->sub_runner_nodes) {
       r_it->ctrl_g->runner_node = &(*r_it);
     }
   }
